{"componentChunkName":"component---src-templates-blog-post-js","path":"/exponential-backoff/","webpackCompilationHash":"fa99990c45891a7f0d3f","result":{"data":{"site":{"siteMetadata":{"title":"Wandering but not lost","author":"Sohaib Tariq"}},"markdownRemark":{"id":"6560b272-bfd9-5242-9179-d4ed4f5d6325","excerpt":"I recently set up a Lambda function that reads data from an SQS Queue \nand makes an API call to one of our microservices. \nNaturally, this calls for an errorâ€¦","html":"<p>I recently set up a Lambda function that reads data from an SQS Queue\nand makes an API call to one of our microservices.\nNaturally, this calls for an error handling mechanism, considering that the microservice\ncould be down or unresponsive.</p>\n<p>AWS Lambda provides its own retry mechanism where a message is picked up from the queue by the Lambda\nconsumer and becomes invisible to other consumers for a specific duration called the <em>visibility timeout</em>.\nIf the consumer completes execution successfully, it automatically deletes the message from the queue.\nIn case of unsuccesful execution (such as a Runtime Exception), the <em>approximate receive count</em>\nof the message is incremented and it becomes available to other consumers after the <em>visibility timeout</em> passes.\nThe number of times a message can be re-read from the queue\nbefore it is finally sent to a Dead Letter Queue(DLQ) is configured in the Redrive policy of the\nSQS Queue and is tracked via the <em>approximate receive count</em>.</p>\n<p>This retry mechanism was not exactly what I had in mind for our use case. I was thinking along the\nlines of a backoff strategy that keeps retrying the API call with exponentially increasing wait time;\nfinally sending the message to a DLQ after a set number of retries. This would give us ample time to\nfix any issues with our miscroservice and prevent it from being bombarded with failing API calls. </p>\n<p>This is what I ended up with: </p>\n<p>First, a very basic Java function to calculate the exponential wait time, given the number of\nretries <strong>recvCount</strong>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">        int randomInt = rand.nextInt(60);\n        Long result = new Double(Math.pow(2, recvCount)).longValue() + 30 +randomInt;  //adding jitter to new random visibility timeout</code></pre></div>\n<p>Notice the addition of <strong>randomInt</strong>. That is 'jitter'. A bit of randomness. I read about it in some\n<a href=\"https://cloud.google.com/storage/docs/exponential-backoff\">documentation</a> by Google Cloud and included\nit as a good practice.</p>\n<p>Next up, set the visibility timeout of the message to the value that we just calculated above. The maximum value allowed by AWS is 43200 seconds\nor 12 hours. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  sqs.changeMessageVisibility(queueUrl, msg.getReceiptHandle(), newVisibilityTimeout.intValue());</code></pre></div>\n<p>Finally, we check the response to our API call. If it is a 400 or 500 series response, we throw a Runtime Exception and change the visibility timeout of the\nmessage. This is\nthe easiest way I could come up with to signal unsuccessful execution of the Lambda function. Plus, we can only throw unchecked exceptions\nin our handler method.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n// api call\n...  \n if (response.getStatusLine().getStatusCode() &gt;= 400){\n                            new ExponentialBackoff().setVisibilityTimeout(msg);\n                            throw new RuntimeException(&quot;Request to server failed&quot;);\n                        }</code></pre></div>\n<p>ExponentialBackoff is my utility class where the code that calculates and sets the visibility timeout lives. It also has some other\nutility functions that are not essential for this demonstration.</p>\n<p>There you have it; A bare bones exponential backoff implementation for AWS Lambda. </p>","frontmatter":{"title":"Exponential backoff for AWS Lambda","date":"August 19, 2019","description":"A very basic Java implementation of exponential backoff for AWS Lambda"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/exponential-backoff/","previous":null,"next":null}}}